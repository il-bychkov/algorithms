# Динамическое прграммирование: задачи
### Задача "Хорошая и плохая двоичная строка"
#### Условие:
Дана бинарная строка. Если в ней нет подстроки "00", то будем её называть хорошей. Иначе плохой.
Требуется посчитать, сколько существует хороших строчек длины n.
#### Brute force: 
Генерируем 2^n строчек и каждую проверяем, хорошая ли. 
Сложность - O(2^n).
#### Использование парадигмы динамического программирования
Представим, что имеем 2 хорошие строчки размером меньше. Тогда они заканчиваются одна на 1, другая на 0. Та, которая на 0, обязана иметь единицу до этого нуля, иначе она будет плохой. Тогда формула для заполнения нашего массива: d[i] = d[i-1] + d[i-2].

##### Тривиальные случаи:
Осталось определиться с тривиальными случаями. Их можно посчитать руками, строчки не длинные. 

d[2] = 3, 
d[1] = 2 
Тогда d[0] = 1
Действительно, d[3] = 3 + 2 = 5.

### Задача "Хорошая и плохая k-ичная строка"

Теперь решим задачу в общем виде: строка k-ичная. Надо определить то же самое.
#### Использование парадигмы динамического программирования
Если строка заканчивается на 0, то до него стоит что либо, кроме ноля, то есть k-1 вариантов. 

Если строка заканчивается не на 0, то до этого символа стоит что угодно, на это доп условий можно не накладывать. 

Итого соотношение d[i] = (d[i-1] + d [i-2]) * (k-1)

##### Тривиальные случаи:

Пусть k=3, то есть строка 3-ичная.

d[1] = 3, d[0] = 1. Тогда d[0] = 1 

Действительно, d[2] = 4*2 = 8. Если посчитать руками, то получается именно так.

### Editing distance (расстояние Ливенштейна, расстояние редактирования)
#### Условие:
Даны 2 строки: A[1..n], B[1..m]

Доступные операции: удаление, добавление и замена буквы. Необходимо определить, за какое минимальное количество операций можем получить строку А из строки В.

> Практическое применение: исправление опечаток в текстовом редакторе (по типу: *возможно, вы имели в виду это слово: ...*)
> 
Возьмём первые i символов из A и первые j символов из B. Посмотрим, как могут располагаться эти строки в ответе:

1 случай:
```
a_i
b_j
```

2 случай:
```
—
b_j
```
3 случай:
```
a_i
—
```
Пусть D_{ij} - матрица ответов для строки А длиной i и строки B длиной j.

Тогда первый случай можно посчитать так: 

`d[i-1][j-1] + diff(a_i, b_j)`, где diff вернёт 1, если символы разные и 0, если равные.

Второй случай: `d[i-1][j] + 1`

Третий случай: `d[i][j-1] + 1`

И нужно выбрать минимальный из этих трёх вариантов по стоимости.

### Задача о рюкзаке
#### 1 вариант: fractional knapsack
Представим, что предметы можно резать.

Если рюкзак unbounded (неограниченный), то берём самую дорогую вещь по соотношению вес/цена и ей по максимуму забиваем рюкзак.

Если рюкзак 0-1, то сначала отсортируем предметы по соотношению вес/цена и будем брать самые лучшие.

#### 2 вариант: unbounded knapsack

Тут мы можем брать неограниченное количество предметов каждого типа.

Создадим матрицу d[Q] - лучшая цена рюкзака, вмещающего Q кг. Тогда нужно выбрать максимум из следующих вариантов:

```d[Q - w_1] + P_1```

```d[Q - w_2] + P_2```

...

```d[Q - w_n] + P_n```

Где P_i - цена i-го предмета.

Complexity: O(n * capacity) - так называемая pseudo polynomial сложность

#### 3 вариант: 0-1 knapsack

Тут мы можем лишь решить, берём мы вещь или нет. Каждой вещи у нас по 1 экземпляру.

Решается так же, как предыдущий вариант, но с помощью матрицы. Пусть матрица D_{ij} будет хранить максимальную стоимость рюкзака с текущим весом i, а для рюкзака доступны предметы с индексами не более, чем j. Тогда:

`d[i][j]= d[i][j-1]` (если j-ую вещь не берём)

`d[i][j]= d[i-w_j][j-1] + P_j` (если j-ую вещь берём)

Complexity: O(n * capacity)
